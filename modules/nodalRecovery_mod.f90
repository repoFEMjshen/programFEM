
      ! Nodal Recovery module
      !----------------------
      !
      !   this module is used to approximate the nodal values of a FE-field using  the Gauss-point values.
      !   Three methods are supported:
      !     1 - (rec_AVG) - weighted averaging over the locally-connected elements
      !
      !                   see subroutines: nodalAveraging, nodalAveraging_PL
      !
      !     2 - (rec_SPR) - Superconvergent Patch Recovery
      !
      !                   see subroutine:  recoverySPR
      !
      !     3 - (rec_LSQ) - Least-Square Fit of the FE-interpolated field on the Gauss point values
      !
      !                   see subroutine:  recoveryLSQ, recoveryLSQ_PL
      !
      !  The module needs to be initialized (once) before the recovery subroutines are called within your program. 
      !  Initialization provides some basic information for the module to operate. This can be done in two ways.
      !     1 - using an external file that contains the SPR patches and node-to-element connectivity that will be
      !       needed during recovery. SPR recovery requires this type of initialization.
      !       Another program, calcPatches is used to generate this mesh-specific file,
      !       and is available in the tools/ folder of this repository.
      !       This approach is not (yet) memory-efficient because the lists are stored in non-compact data structures.
      !
      !       see subroutine: initialize_Patches
      !       required for:   nodalAveraging_PL, recoverySPR, recoveryLSQ_PL
      !
      !     2 - using the data structures generated by the Grains Module. 
      !       this is a memory efficient initialization method, that enables methods 1(rec_AVG) and 3(rec_LSQ) for use.
      !       
      !       see subroutine: initialize_GrainNodes
      !       required for:   nodalAveraging, recoveryLSQ
      !
      !-----------------------
      ! Authors: Deniz Ozturk, Ahmad Shahba
      !-----------------------
      module nodalRecovery
      
      private :: calcJacTET4,getElemXCenter,getElemXNodes,rec_READSTR
      
      ! recovery methods
      integer, parameter :: rec_AVG = 1   ! weighted averaging
      integer, parameter :: rec_SPR = 2   ! Superconvergent Patch Recovery
      integer, parameter :: rec_LSQ = 3   ! Least-Square Fit
      
      ! major mesh structures. 
      ! these are initialized with the nodalRecovery module at the start of the program.
      integer :: nSPRPatches      
      integer, private :: rec_nGrains,rec_nTotGrainNodes
      integer, private :: rec_NX,rec_NELX,rec_NODE
      integer, private, allocatable :: rec_IJK(:)
      real(8), private, allocatable :: rec_nodalPositions(:,:) ! MEMORY EFF IMPROVEMENT: instead of importing this, consider taking G0XYZ as arguments into the operating subroutines.
      integer, private, allocatable :: IJK_patchNodes(:,:)
      real(8), private, allocatable :: xElemCenter(:,:)
      
      ! field/grain segmentation of elements
      integer, private, allocatable :: rec_nGrainElements(:)
      integer, private, allocatable :: rec_grainElements(:)
      integer, private, allocatable :: rec_grainElementIndx(:)
      
      ! non-local patches
      integer, allocatable:: listPatchElementsNonlocal(:,:)
      integer, allocatable:: nPatchElementsNonLocal(:)
      integer, allocatable:: listPatchNodesNonLocal(:,:)
      integer, allocatable:: listPatchGlobalNodesNonLocal(:,:)
      integer, allocatable:: nPatchNodesNonLocal(:)
      real(8), allocatable:: distPatchElementsNonLocal(:,:)
      
      ! local patches
      integer, allocatable:: listPatchElementsLocal(:,:)
      integer, allocatable:: nPatchElementsLocal(:)
      integer, allocatable:: listPatchNodesLocal(:,:)
      integer, allocatable:: listPatchGlobalNodesLocal(:,:)
      integer, allocatable:: nPatchNodesLocal(:)
      real(8), allocatable:: distPatchElementsLocal(:,:)
      
      integer :: nMaxPatchElementsLocal, nMaxPatchElementsNonLocal
      integer :: nMaxPatchNodesLocal, nMaxPatchNodesNonLocal
      integer :: nMaxPatchNodes, nMaxPatchElements
      integer :: nMaxPatchesPerGrain

      ! patchID-nodeID mappings
      integer, allocatable :: listPatchesInGrain(:,:)
      integer, allocatable :: nPatchesInGrain(:)
      integer, allocatable :: patchGrainID(:)
      integer, allocatable :: nodeIDFromPatchID(:)
      integer, allocatable :: patchIDFromNodeID(:)
      
      ! boundary nodes
      logical, allocatable :: isBoundaryNode(:)
      
      ! settings
      logical :: normalize_SPR
      
      ! state
      logical :: patchesInitialized
      logical :: grainNodesInitialized

      
      contains
      
      SUBROUTINE initialize_GrainNodes(NX,NELX,NODE,nGrains,nTotGrainNodes)
      
      implicit none
      
      integer, intent(in) :: NX,NELX,NODE,nGrains,nTotGrainNodes
      
      rec_NX = NX
      rec_NELX = NELX
      rec_NODE = NODE
      rec_nGrains = nGrains
      rec_nTotGrainNodes = nTotGrainNodes
      
      grainNodesInitialized = .true.
     
      
      END SUBROUTINE
      
      SUBROUTINE initialize_Patches(strPatchFile, &
                         NX,NELX,IJK,G0XYZ)
      
      implicit none
      
      character(len=*), intent(in) :: strPatchFile
      integer, intent(in) :: NX,NELX,IJK(:)
      real(8), intent(in) :: G0XYZ(:)

      !locals
      integer :: I,J,N,ISTART,IEND,INC,error,iLocNode
      integer :: lastIndex, iIndex, staIndex, endIndex, nodeIdx, elemIdx
      integer :: elemID, iGrain, patchID, nodeID
      real(8) :: dist(3)
      logical :: fileExists
      logical, allocatable :: elementAdded(:)
      character(len=150) :: lineStr
      
      patchesInitialized = .false.
      
      inquire(file=strPatchFile,exist=fileExists)
      if(.NOT.fileExists) RETURN

      open(51,file=trim(strPatchFile))
      read(51,*) nSPRPatches
      call rec_READSTR(51,lineStr,error) ! 'patchIDs'
      read(51,*) rec_NX,rec_NELX,rec_nGrains,rec_NODE
      if (NX /= rec_NX .or. NELX /= rec_NELX) then
         write(*,*) 'imported mesh and patch data file are inconsistent' 
         write(*,*) NX,NELX, rec_NX,rec_NELX
         return
      endif
      read(51,*) nMaxPatchesPerGrain
      read(51,*) nMaxPatchElementsLocal
      read(51,*) nMaxPatchNodesLocal
      read(51,*) nMaxPatchElementsNonLocal
      read(51,*) nMaxPatchNodesNonLocal
      
      nMaxPatchElements = MAX(nMaxPatchElementsLocal,nMaxPatchElementsNonLocal)
      nMaxPatchNodes = MAX(nMaxPatchNodesLocal,nMaxPatchNodesNonLocal)
      
      allocate(listPatchesInGrain(nMaxPatchesPerGrain,rec_nGrains))
      allocate(nodeIDFromPatchID(nSPRPatches))
      allocate(nPatchesInGrain(rec_nGrains))
      do iGrain=1,rec_nGrains
         read(51,*) nPatchesInGrain(iGrain), (listPatchesInGrain(nodeIdx,iGrain),nodeIdx=1,nPatchesInGrain(iGrain))
         read(51,*) (nodeIDFromPatchID(listPatchesInGrain(nodeIdx,iGrain)),nodeIdx=1,nPatchesInGrain(iGrain))
      enddo
      
      call rec_READSTR(51,lineStr,error) ! 'listPatchElementsLocal'
      allocate(listPatchElementsLocal(nMaxPatchElementsLocal,nSPRPatches))
      allocate(distPatchElementsLocal(nMaxPatchElementsLocal,nSPRPatches))
      allocate(listPatchNodesLocal(nMaxPatchNodesLocal,nSPRPatches))
      allocate(listPatchGlobalNodesLocal(nMaxPatchNodesLocal,nSPRPatches))
      allocate(nPatchElementsLocal(nSPRPatches))
      allocate(nPatchNodesLocal(nSPRPatches))
      do patchID=1,nSPRPatches
         read(51,*) nPatchElementsLocal(patchID)
         read(51,*) (listPatchElementsLocal(elemIdx,patchID),elemIdx=1,nPatchElementsLocal(patchID))
         read(51,*) nPatchNodesLocal(patchID)
         read(51,*) (listPatchNodesLocal(nodeIdx,patchID),nodeIdx=1,nPatchNodesLocal(patchID))
         read(51,*) (listPatchGlobalNodesLocal(nodeIdx,patchID),nodeIdx=1,nPatchNodesLocal(patchID))
      enddo
      
      
      call rec_READSTR(51,lineStr,error) ! 'listPatchElementsNonLocal'
      allocate(listPatchElementsNonLocal(nMaxPatchElementsNonLocal,nSPRPatches))
      allocate(distPatchElementsNonLocal(nMaxPatchElementsNonLocal,nSPRPatches))
      allocate(listPatchNodesNonLocal(nMaxPatchNodesNonLocal,nSPRPatches))
      allocate(listPatchGlobalNodesNonLocal(nMaxPatchNodesNonLocal,nSPRPatches))
      allocate(nPatchElementsNonLocal(nSPRPatches))
      allocate(nPatchNodesNonLocal(nSPRPatches))
      do patchID=1,nSPRPatches
         read(51,*) nPatchElementsNonLocal(patchID)
         read(51,*) (listPatchElementsNonLocal(elemIdx,patchID),elemIdx=1,nPatchElementsNonLocal(patchID))
         read(51,*) nPatchNodesNonLocal(patchID)
         read(51,*) (listPatchNodesNonLocal(nodeIdx,patchID),nodeIdx=1,nPatchNodesNonLocal(patchID))
         read(51,*) (listPatchGlobalNodesNonLocal(nodeIdx,patchID),nodeIdx=1,nPatchNodesNonLocal(patchID))
      enddo
      
      call rec_READSTR(51,lineStr,error) ! 'isBoundaryNode'
      allocate(isBoundaryNode(nSPRPatches))
      do patchID=1,nSPRPatches
         read(51,*) isBoundaryNode(patchID)
      enddo            
      
      close(51)
      
      allocate(patchGrainID(nSPRPatches))
      do iGrain=1,rec_nGrains
         do nodeIdx = 1,nPatchesInGrain(iGrain)
            patchID = listPatchesInGrain(nodeIdx,iGrain)
            patchGrainID(patchID) = iGrain
         enddo
      enddo
      
      ! import nodal positions as a matrix
      allocate(rec_nodalPositions(3,rec_NX))
      rec_nodalPositions = 0.d0
      do nodeID=1,rec_NX
         rec_nodalPositions(1:3,nodeID)=G0XYZ((nodeID-1)*3+1:nodeID*3)
      enddo
      
      ! import connectivity matrix.
      allocate(rec_IJK(rec_NODE*rec_NELX))
      rec_IJK = IJK
      
      ! construct connectivity matrix for patchNodes (element -> 4 patchNodes)
      allocate(IJK_patchNodes(rec_NODE,rec_NELX))
      IJK_patchNodes = 0
      allocate(patchIDFromNodeID(rec_NX))
      do iGrain=1,rec_nGrains
               
         ! initialize the temporary inverse mapping array
         patchIDFromNodeID = 0
         
         do nodeIdx = 1,nPatchesInGrain(iGrain)
         
            patchID = listPatchesInGrain(nodeIdx,iGrain)
            nodeID = listPatchGlobalNodesLocal(1,patchID)
                  
            ! add to the temporary array for inverse mapping: global Node ID --> patchID (only valid for this grain)
            patchIDFromNodeID(nodeID) = patchID
         enddo
      
         do nodeIdx = 1,nPatchesInGrain(iGrain)
            patchID = listPatchesInGrain(nodeIdx,iGrain)
            do elemIdx=1,nPatchElementsLocal(patchID)
               elemID = listPatchElementsLocal(elemIdx,patchID)
               if (IJK_patchNodes(1,elemID)==0) then
                  IJK_patchNodes(:,elemID) = patchIDFromNodeID(rec_IJK((elemID-1)*rec_NODE+1:elemID*rec_NODE))
               endif
            enddo
         enddo
      enddo
      deallocate(patchIDFromNodeID)

      ! calculate and save gauss point positions (TET geometric center)
      allocate(xElemCenter(3,rec_NELX))
      xElemCenter = 0.d0      
      do elemID=1,rec_NELX
         do iLocNode=1,rec_NODE
            nodeID=rec_IJK((elemID-1)*rec_NODE+iLocNode)
            xElemCenter(:,elemID) = xElemCenter(:,elemID) &
               + rec_nodalPositions(:,nodeID)
         enddo
         xElemCenter(:,elemID)=xElemCenter(:,elemID)/rec_NODE
      enddo
      
      ! construct grain element lists
      
      allocate(rec_nGrainElements(rec_nGrains))
      allocate(rec_grainElements(rec_NELX))
      allocate(rec_grainElementIndx(rec_nGrains))
      allocate(elementAdded(rec_NELX))
      elementAdded = .false.
      rec_nGrainElements = 0
      rec_grainElementIndx = 0
      lastIndex = 0
      do iGrain=1,rec_nGrains
         do nodeIdx = 1,nPatchesInGrain(iGrain)
            patchID = listPatchesInGrain(nodeIdx,iGrain)
            do elemIdx=1,nPatchElementsLocal(patchID)
               elemID = listPatchElementsLocal(elemIdx,patchID)
               if(.not.elementAdded(elemID)) then  ! add element to the list of elements in this grain/field
                  rec_nGrainElements(iGrain) = rec_nGrainElements(iGrain) + 1
                  lastIndex = lastIndex + 1
                  rec_grainElements(lastIndex) = elemID
                  elementAdded(elemID) = .true.
               endif
            enddo
         enddo
         rec_grainElementIndx(iGrain) = lastIndex + 1
      enddo
      deallocate(elementAdded)
      
      ! calculate gauss point distances to patch nodes
      do patchID=1,nSPRPatches
         ! local patches
         do elemIdx=1,nPatchElementsLocal(patchID)
            elemID = listPatchElementsLocal(elemIdx,patchID)
            nodeID = listPatchGlobalNodesLocal(1,patchID)
            dist(:) = xElemCenter(:,elemID) - rec_nodalPositions(:,nodeID)
            distPatchElementsLocal(elemIdx,patchID) = dSqrt(dot_product(dist,dist))
         enddo
         ! nonlocal patches
         do elemIdx=1,nPatchElementsNonLocal(patchID)
            elemID = listPatchElementsNonLocal(elemIdx,patchID)
            nodeID = listPatchGlobalNodesNonLocal(1,patchID)
            dist(:) = xElemCenter(:,elemID) - rec_nodalPositions(:,nodeID)
            distPatchElementsNonLocal(elemIdx,patchID) = dSqrt(dot_product(dist,dist))
         enddo
      enddo
     
      patchesInitialized = .true.
      
      END SUBROUTINE
      
      SUBROUTINE getElemNodalValues_PL(elemID,elemNodalValues, &
                                                  nodalValues, &
                                                    nQuantDOF, &
                                                        error)
      implicit none 
      integer, intent(in) :: elemID
      real(8), intent(out):: elemNodalValues(nQuantDOF,rec_NODE)
      real(8), intent(in) :: nodalValues(nQuantDOF,nSPRPatches)
      integer, intent(in) :: nQuantDOF
      integer, intent(out):: error
      
      ! locals
      integer :: iNode,iGloNode,patchID
      
      error = 1      
      if (.not.patchesInitialized) return

      do iNode=1,rec_NODE
         patchID = IJK_patchNodes(iNode,elemID)
         elemNodalValues(:,iNode)=nodalValues(:,patchID)
      enddo
      
      error = 0
      
      END SUBROUTINE
      
      SUBROUTINE getElemNodalValues(elemID,elemNodalValues, &
                                               nodalValues, &
                                                 nQuantDOF, &
                                            IJK_grainNodes, &
                                                     error)
      implicit none 
      integer, intent(in) :: elemID
      real(8), intent(out):: elemNodalValues(nQuantDOF,rec_NODE)
      real(8), intent(in) :: nodalValues(nQuantDOF,rec_nTotGrainNodes)
      integer, intent(in) :: nQuantDOF
      integer, intent(in) :: IJK_grainNodes(rec_NODE,rec_NELX)
      integer, intent(out):: error
      
      ! locals
      integer :: iNode,iGloNode,grainNodeID
      
      error = 1      
      if (.not.grainNodesInitialized) return

      do iNode=1,rec_NODE
         grainNodeID = IJK_grainNodes(iNode,elemID)
         elemNodalValues(:,iNode)=nodalValues(:,grainNodeID)
      enddo
      
      error = 0
      
      END SUBROUTINE

      ! Nodal recovery using weighted averaging.
      ! this uses the constructs available from grains module for node-element connectivity info.
      ! also see nodalAveraging_PL() that uses an external patch-list file.
      !
      ! nodalValues(:,:,:) : nodal stresses obtained by weighted averaging over surrounding elements
      ! WARNING! -- this does not initialize the whole array
      ! only the nodal values for the grain of interest are initialized
      SUBROUTINE nodalAveraging(nodalValues,gaussValues,nQuantDOF, &
                                G0XYZ,IJK,IJK_grainNodes, &
                                error)
      implicit none
      real(8), intent(out):: nodalValues(nQuantDOF,rec_nTotGrainNodes)
      real(8), intent(in) :: gaussValues(nQuantDOF,rec_NELX)
      integer, intent(in) :: nQuantDOF
      real(8), intent(in) :: G0XYZ(3*rec_NX)
      integer, intent(in) :: IJK(4*rec_NELX),IJK_grainNodes(4,rec_NELX)
      integer, intent(out):: error
      
      ! local variables
      integer :: iElem,iLocNode,grainNodeID,nodeID
      real(8) :: weight,normalization(rec_nTotGrainNodes)
      real(8) :: dist, distVec(3), elemCenter(3), xNodes(3,4)
      
      error = 1
      if (.not.grainNodesInitialized) return
      
      normalization = 0.d0
      nodalValues(:,:) = 0.D0

      do iElem = 1,rec_NELX
         
         do iLocNode=1,4
            
            grainNodeID = IJK_grainNodes(iLocNode,iElem)
            nodeID = IJK((iElem-1)*rec_NODE+iLocNode)
            CALL getElemXCenter(iElem,IJK,G0XYZ,rec_NODE,elemCenter(:))
            
            distVec(:) = elemCenter(:) - G0XYZ((nodeID-1)*3+1:nodeID*3)
            dist = dsqrt(DOT_PRODUCT(distVec,distVec))
            weight = 1.d0 / dist
            nodalValues(:,grainNodeID) = nodalValues(:,grainNodeID) + gaussValues(:,iElem)*weight
            normalization(grainNodeID) = normalization(grainNodeID) + weight
             
         enddo         
      enddo
      
      do grainNodeID=1,rec_nTotGrainNodes
         if (normalization(grainNodeID) /= 0.d0) then
            nodalValues(:,grainNodeID) = nodalValues(:,grainNodeID) / normalization(grainNodeID)
         endif
      enddo
      error = 0
      
      END SUBROUTINE
      

      ! Nodal recovery using weighted averaging -- parallel processing
      ! this uses the constructs available from grains module for node-element connectivity info.
      ! also see nodalAveraging_PL() that uses an external patch-list file.
      !
      ! nodalValues(:,:,:) : nodal stresses obtained by weighted averaging over surrounding elements
      ! WARNING! -- this does not initialize the whole array
      ! only the nodal values for the grain of interest are initialized
      SUBROUTINE nodalAveragingParallel(nodalValues,gaussValues,nQuantDOF, &
                                        G0XYZ, &
                                        grainElementIndx,grainElements,IJK,IJK_grainNodes, &
                                        staGrainIdx,endGrainIdx,error)
      implicit none
      real(8), intent(out):: nodalValues(nQuantDOF,rec_nTotGrainNodes)
      real(8), intent(in) :: gaussValues(nQuantDOF,rec_NELX)
      integer, intent(in) :: nQuantDOF
      real(8), intent(in) :: G0XYZ(3*rec_NX)
      integer, intent(in) :: grainElements(rec_NELX)      
      integer, intent(in) :: grainElementIndx(rec_nGrains)
      integer, intent(in) :: IJK(4*rec_NELX),IJK_grainNodes(4,rec_NELX)
      integer, intent(out):: error
      integer, intent(in) :: staGrainIdx,endGrainIdx
      
      ! local variables
      integer :: iElem,iLocNode,grainNodeID,nodeID
      real(8) :: weight,normalization(rec_nTotGrainNodes)
      real(8) :: dist, distVec(3), elemCenter(3), xNodes(3,4)
      integer :: staElemIdx,endElemIdx,firstGrain,lastGrain,iGrain
      
      error = 1
      if (.not.grainNodesInitialized) return
      
      normalization = 0.d0
      nodalValues(:,:) = 0.D0

      if (staGrainIdx==0 .and. endGrainIdx==0) then
         error=0
         return
      endif
      
      do iGrain=staGrainIdx,endGrainIdx
      
         staElemIdx = 1
         if (iGrain.NE.1) staElemIdx = grainElementIndx(iGrain-1)
         endElemIdx = grainElementIndx(iGrain)-1

         do iElem = staElemIdx,endElemIdx
            
            do iLocNode=1,4
               
               grainNodeID = IJK_grainNodes(iLocNode,iElem)
               nodeID = IJK((iElem-1)*rec_NODE+iLocNode)
               CALL getElemXCenter(iElem,IJK,G0XYZ,rec_NODE,elemCenter(:))
               
               distVec(:) = elemCenter(:) - G0XYZ((nodeID-1)*3+1:nodeID*3)
               dist = dsqrt(DOT_PRODUCT(distVec,distVec))
               weight = 1.d0 / dist
               nodalValues(:,grainNodeID) = nodalValues(:,grainNodeID) + gaussValues(:,iElem)*weight
               normalization(grainNodeID) = normalization(grainNodeID) + weight
                
            enddo         
         enddo
      enddo
      
      do grainNodeID=1,rec_nTotGrainNodes
         if (normalization(grainNodeID) /= 0.d0) then
            nodalValues(:,grainNodeID) = nodalValues(:,grainNodeID) / normalization(grainNodeID)
         endif
      enddo
      
      error = 0      
      END SUBROUTINE
      
      ! Nodal recovery using weighted averaging.
      ! this uses the patch list imported from a file for node-element connectivity info. must do initialize_Patches() first.
      ! also see nodalAveraging() that uses constructs available from grains module.
      !
      ! nodalValues(:,:,:) : nodal stresses obtained by weighted averaging over surrounding elements
      ! WARNING! -- this does not initialize the whole array
      ! only the nodal values for the grain of interest are initialized
      SUBROUTINE nodalAveraging_PL(nodalValues,gaussValues,nQuantDOF, &
                                   error)
      implicit none
      real(8), intent(out):: nodalValues(nQuantDOF,nSPRPatches)
      real(8), intent(in) :: gaussValues(nQuantDOF,rec_NELX)
      integer, intent(in) :: nQuantDOF
      integer, intent(out):: error
      
      ! local variables
      integer :: iElem,patchID,elemIdx,nodeID
      real(8) :: dist,distVec(3),elemCenter(3),xNodes(3,4),weight,normalization
      
      error = 1
      if (.not.patchesInitialized) return
      
      ! initialize values for this patch-node
      nodalValues(:,:) = 0.D0

      do patchID = 1, nSPRPatches
         
         nodeID = nodeIDFromPatchID(patchID)
         normalization = 0.d0
         
         do elemIdx = 1,nPatchElementsLocal(patchID)
            iElem = listPatchElementsLocal(elemIdx,patchID)

            distVec(:) = xElemCenter(:,iElem) - rec_nodalPositions(:,nodeID)
            dist = dsqrt(DOT_PRODUCT(distVec,distVec))
            weight = 1.d0 / dist
            nodalValues(:,patchID) = nodalValues(:,patchID) + gaussValues(:,iElem)*weight
            normalization = normalization + weight
               
         enddo

         if (normalization /= 0.d0) then 
            nodalValues(:,patchID) =0.D0
         else
            nodalValues(:,patchID) = &
               nodalValues(:,patchID) / normalization
         endif
         
      enddo
      
      error = 0
      
      END SUBROUTINE

      SUBROUTINE recoverySPR(nodalValues,gaussValues,nQuantDOF, &
                         p_deg,regularizeBoundaries,localNonlocal, &
                                      nFailedPatches,info,debug)
      implicit none
      !arguments
      integer, intent(in) :: nQuantDOF
      integer, intent(in) :: p_deg   ! requested degree of the patching polynomials
      logical, intent(in) :: regularizeBoundaries  ! always take patch averages for the boundary nodes
      integer, intent(in) :: localNonlocal   ! use local or non-local patches
      real(8), intent(out):: nodalValues(nQuantDOF,nSPRPatches)
      real(8), intent(in) :: gaussValues(nQuantDOF,rec_NELX)
      integer, intent(out) :: nFailedPatches
      integer, intent(out):: info
      logical, intent(in) :: debug
      ! local variables
      real(8) :: nodalValues_NonLocal(nQuantDOF,nSPRPatches)
      real(8) :: nodalValuesPatch(nQuantDOF,nMaxPatchNodes)
      integer :: nContributionsOnNodalValues(nSPRPatches)
      logical :: patchSuccessful(nSPRPatches)
      integer :: iEl,iNode,jNode,jNodeIdx,iLocNode,nElem, &
                  elemIdx,staElemIdx,endElemIdx,nodeID, &
                  iQuantDOF,iGloNode,iDOF,i,j,nodeIdx,patchID,patchIDnode
      integer :: nPolyTerms
      real(8) :: condN

      nodalValues(:,:) = 0.D0          ! nodal values calculated using SPR. this is the main output
      nodalValues_NonLocal(:,:) = 0.d0 ! nodal values calculated using SPR with patches 
                                       !     contributing to the non-central nodes as well.
                                       !     we need this in case patching fails for a boundary node.
                                       !     in those cases we use contributions coming from surrounding patches
      nContributionsOnNodalValues(:) = 0 ! # of non-local contributions made on each node from patches. 
                                         !      this count is used for calculating the average after summing the contributions
      patchSuccessful(:) = .false.
      info = 1
      if (.not.patchesInitialized) return
      
      do patchID=1,nSPRPatches
      
         nPolyTerms=(p_deg+3)*(p_deg+2)*(p_deg+1)/6

         CALL calculatePatchSPR(patchID,p_deg, &
                   nQuantDOF,gaussValues(:,:), &
                        nodalValuesPatch(:,:), &
               localNonlocal,condN,INFO,debug)

         if(info.NE.0) then
           write(131,*)  'ERROR in calculatePatchSPR'
           patchSuccessful(patchID) = .false.
           cycle
         endif
         
         patchSuccessful(patchID) = .true.
         
         ! add the contribution from the patch to its central node
         nodalValues(:,patchID) = nodalValuesPatch(:,1)
         
         ! add the contribution from the patch to all patch nodes (non-local contrib.)
         if (localNonlocal == 1) then
            do nodeIdx = 1,nPatchNodesLocal(patchID)
               patchIDnode = listPatchNodesLocal(nodeIdx,patchID)
               nodalValues_NonLocal(:,patchIDnode) = &
                  nodalValues_NonLocal(:,patchIDnode) + nodalValuesPatch(:,nodeIdx)
               nContributionsOnNodalValues(patchIDnode) = nContributionsOnNodalValues(patchIDnode) + 1
            enddo
         else
            do nodeIdx = 1,nPatchNodesNonLocal(patchID)
               patchIDnode = listPatchNodesNonLocal(nodeIdx,patchID)
               nodalValues_NonLocal(:,patchIDnode) = &
                  nodalValues_NonLocal(:,patchIDnode) + nodalValuesPatch(:,nodeIdx)
               nContributionsOnNodalValues(patchIDnode) = nContributionsOnNodalValues(patchIDnode) + 1
            enddo
         endif
         
      enddo
      
      ! take the average of accummulated nodal values
      do patchID=1,nSPRPatches
         if (nContributionsOnNodalValues(patchID)==0) then
            write(*,*) 'no contributions done to patch node:', patchID
            info = -1
            !return
            !stop
         endif
         nodalValues_NonLocal(:,patchID) = nodalValues_NonLocal(:,patchID) / nContributionsOnNodalValues(patchID)       
      enddo

      ! for the patches that have failed, use contributions from neigboring patches
      nFailedPatches = 0
      do patchID=1,nSPRPatches
         if (.not.patchSuccessful(patchID)) then
            nFailedPatches = nFailedPatches + 1
            nodalValues(:,patchID) = nodalValues_NonLocal(:,patchID)
         endif
         ! also, if required, for nodes on the grain/domain boundary do an averaging to alleviate overshooting
         if (regularizeBoundaries.and.isBoundaryNode(patchID)) then
            nodalValues(:,patchID) = nodalValues_NonLocal(:,patchID)         
         endif
      enddo

      END SUBROUTINE

      SUBROUTINE calculatePatchSPR(patchID,p_deg, &
                                       nQuantDOF, &
                                     gaussValues, &
                                nodalValuesPatch, &
                  localNonlocal,condN,INFO,debug)
                                  
      implicit none
      !arguments
      integer, intent(in) :: patchID
      integer, intent(in) :: p_deg       ! degree of the patching polynomial requested/applied
      integer, intent(in) :: localNonlocal   ! use local or non-local patches
      integer, intent(in) :: nQuantDOF
      real(8), intent(in) :: gaussValues(nQuantDOF,rec_NELX)
      real(8), intent(out):: nodalValuesPatch(nQuantDOF,nMaxPatchNodes)
      real(8), intent(out):: condN
      integer, intent(out) :: info
      logical, intent(in) :: debug

      logical, parameter :: debug1 = .false.
      logical, parameter :: debug2 = .false.
      
      ! local variables
      real(8) :: quantThisNode(nQuantDOF)
      integer :: iElem,iNode,nodeID,iLocNode,elemIdx,staElemIdx,MDIM, &
                  endElemIdx,iNodeIdx,iQuantDOF,iGloNode,iDOF,i,j
      real(8) :: xNode(3),xPatchCenter(3),iNodeX(3)
      real(8) :: xPatchRange(3,2)
      real(8) :: xPatchGauss(3,nMaxPatchElements)
      integer :: nPatchElements, nPatchNodes
      integer :: listPatchElements(nMaxPatchElements)
      real(8) :: distPatchElements(nMaxPatchElements)
      integer :: listPatchGlobalNodes(nMaxPatchNodes)
      ! patch calculation
      real(8), allocatable :: P(:)
      real(8), allocatable :: A(:,:)
      real(8), allocatable :: b(:,:)
      integer :: nPolyTerms


      nPolyTerms=(p_deg+3)*(p_deg+2)*(p_deg+1)/6
      
      MDIM = 3
      
      ! now we have enough elements to calculate coefficients
!****** initialize coefficient arrays
      ! get the coordinates of the central node
      nodeID = nodeIDFromPatchID(patchID)
      xNode(:) = rec_nodalPositions(:,nodeID)
      
      ! loop over the patch elements
      if (localNonlocal == 1) then
         nPatchElements = nPatchElementsLocal(patchID)
         nPatchNodes = nPatchNodesLocal(patchID)
         listPatchElements(1:nPatchElements) = listPatchElementsLocal(1:nPatchElements,patchID)
         listPatchGlobalNodes(1:nPatchNodes) = listPatchGlobalNodesLocal(1:nPatchNodes,patchID)
         distPatchElements(1:nPatchElements) = distPatchElementsLocal(1:nPatchElements,patchID)
      else
         nPatchElements = nPatchElementsNonLocal(patchID)
         nPatchNodes = nPatchNodesNonLocal(patchID)
         listPatchElements(1:nPatchElements) = listPatchElementsNonLocal(1:nPatchElements,patchID)
         listPatchGlobalNodes(1:nPatchNodes) = listPatchGlobalNodesNonLocal(1:nPatchNodes,patchID)
         distPatchElements(1:nPatchElements) = distPatchElementsNonLocal(1:nPatchElements,patchID)
      endif


      xPatchGauss(:,:) = 0.d0
      xPatchCenter(:) = 0.d0
      do elemIdx = 1,nPatchElements
         iElem = listPatchElements(elemIdx)
         xPatchGauss(:,elemIdx) = xElemCenter(:,iElem)
         xPatchCenter(:) = xPatchCenter(:) + xElemCenter(:,iElem)
      enddo
      xPatchCenter = xPatchCenter / nPatchElements
      
      ! translate to origin to improve the conditioning of the A-matrix
      if (normalize_SPR) &
         xPatchGauss(:,elemIdx)=xPatchGauss(:,elemIdx)-xPatchCenter(:)
      
      !calculate the spatial range of the patch
      !small range results in ill-conditioned matrix
      xPatchRange(:,1) = xPatchGauss(:,1)
      xPatchRange(:,2) = xPatchGauss(:,1)
      do elemIdx = 1,nPatchElements
         xPatchRange(:,1)= &
               MIN(xPatchGauss(:,elemIdx),xPatchRange(:,1))
         xPatchRange(:,2)= &
               MAX(xPatchGauss(:,elemIdx),xPatchRange(:,2))
      enddo
      
      ! NORMALIZE all gauss point positions
      if (normalize_SPR) then
         do elemIdx =1,nPatchElements
            xPatchGauss(:,elemIdx) = &
             -1 + 2*(xPatchGauss(:,elemIdx)-xPatchRange(:,1)) &
                     / (xPatchRange(:,2)-xPatchRange(:,1))
         enddo
         if (debug1) write(997,*) 'xPatchGauss normalized'
      endif
      
      
      !form the A and b matrices of the patch
      allocate(P(nPolyTerms))
      allocate(A(nPolyTerms,nPolyTerms))
      allocate(b(nPolyTerms,nQuantDOF))      
      CALL createPatchMatrices(A,b,P,nPolyTerms,nQuantDOF,p_deg, &
                            listPatchElements(:),nPatchElements, &
                                  xPatchGauss,distPatchElements, &
                                 gaussValues,rec_NX,rec_NELX,debug2)

!****** solve for the coeff.s of the patch polynomial *******
      
      ! LAPACK subroutines assume that matrices have
      ! FORTRAN-type (column major) memory layout.
      if (debug1) then
         write(997,*) 'Node: ',nodeID
         write(997,*) '# patch elements: ',nPatchElements
         write(997,*) '# patch nodes: ', nPatchNodes
         CALL printMatrix(A,nPolyTerms,nPolyTerms,'A matrix',997)
         CALL printMatrix(b,nPolyTerms,nQuantDOF,'b vector',997)
         CALL printMatrix(xPatchRange(:,2)-xPatchRange(:,1),1,3, &
                                          'Patch Range',997)
      end if
!     hypothesis: if the gauss pts are positioned in a cubic structure
!     you wont be able to fit a 3D quad polynomial even if N_points>10
!     we need a cental node to 'feel' the curves of the quad bases.
!     test below showed that:
!     inserting a node in the origin of the patch increased the reciprocal conditioning
!     from e-17 to e-5.
!      if(normalize_SPR.AND.p_deg.EQ.2.AND.nNeighDeg.EQ.1
!     &      .AND.nPatchElements.EQ.12) then
!         A(1,1)=A(1,1)+1
!         write(*,'(A,1I5)')'Recovered A singularity! at node',nodeID
!      endif
      CALL DPOSV('U',nPolyTerms,nQuantDOF,A,nPolyTerms,b,nPolyTerms,info)
      if (info.NE.0) then
         !write(*,*)'DPOSV() call at RecoverySPR() returned an error. &
         !                            Node: ', nodeID, &
         !                          'Patch: ', patchID, &
         !                          'nPatchElems:', nPatchElements
         !write(*,*) info
         write(131,*)'DPOSV() call at RecoverSPR() returned an error. &
                                     Node: ', nodeID, &
                                   'Patch: ', patchID, &
                                   'nPatchElems:', nPatchElements
         write(131,*) info
         return
      endif

      ! EVALUATE THE PATCH POLYNOMIAL
      ! ON THE PATCH NODES
      do iNodeIdx=1,nPatchNodes
         ! calculate node position
         iNode = listPatchGlobalNodes(iNodeIdx)
         iNodeX(:) = rec_nodalPositions(:,iNode)
         ! transform to patch coordinate system
         if (normalize_SPR) &
            iNodeX(:)=iNodeX(:)-xPatchCenter(:)
         
         ! NORMALIZE according to patch range
         if (normalize_SPR) then
            iNodeX(:) = &
               -1 + 2*(iNodeX(:)-xPatchRange(:,1)) &
                     / (xPatchRange(:,2)-xPatchRange(:,1))
         endif

         CALL calcPolynomialTET(iNodeX(:),p_deg,P(:),nPolyTerms)
         ! evaluate polynomial at node for each DOF of the quantity
         do iQuantDOF=1,nQuantDOF
            quantThisNode(iQuantDOF)= &
                  DOT_PRODUCT(P(:),b(:,iQuantDOF))
         enddo
         nodalValuesPatch(:,iNodeIdx) = quantThisNode(:)
      enddo
   
      if (debug.and..false.) then
      if (nodalValuesPatch(3,1) > 6000.d0) then
         write(997,*) 'overshoot:', nodalValuesPatch(:,1)
         write(997,*) 'central nodeID',nodeIDFromPatchID(patchID)
         write(997,*) 'at:',rec_nodalPositions(:,nodeIDFromPatchID(patchID))
         write(997,*) 'patchID',patchID
         write(997,*) 'localnonlocal',localNonlocal
         write(997,*) 'nPatchElements',nPatchElements
         write(997,*) 'listPatchElements',listPatchElements(1:nPatchElements)
         do elemIdx = 1,nPatchElements
            iElem = listPatchElements(elemIdx)
            write(997,*) xElemCenter(:,iElem), gaussValues(:,iElem)
         enddo
         
         CALL printMatrix(A,nPolyTerms,nPolyTerms,'A matrix',997)
         CALL printMatrix(b,nPolyTerms,nQuantDOF,'b vector',997)
         CALL printMatrix(xPatchRange(:,2)-xPatchRange(:,1),1,3, &
                                          'Patch Range',997)
      endif
      endif
  
      ! deallocate
      deallocate(P)
      deallocate(A)
      deallocate(b)
     
      END SUBROUTINE

      SUBROUTINE getTET4UnitMatrix(mat)
         ! returns the matrix [I]_ab=integral[N_a(x)*N_b(x)*(dVOL/VOL_e)]
         ! where N_a(x) is the shape function of node a
         ! note: integral is over the 'master' element
         real(8), intent(out):: mat(4,4)
         mat(:,:)= 0.05D0 / 6
         mat(1,1)= 0.1D0 / 6
         mat(2,2)= 0.1D0 / 6
         mat(3,3)= 0.1D0 / 6
         mat(4,4)= 0.1D0 / 6
      END SUBROUTINE
      
      
      ! Used in forming a polynomial of degree p:
      ! a + b*x + c*y + d*z + e*xy + f*yz + g*xz + h*xx + i*yy + ...
      ! k*xxy + l*xyy + m*yyy + .. etc 
      ! given the argument x,y,z, this subroutine returns the terms;
      ! 1, x, y, z, xx, xy, xz, yx ... etc.
      ! dot-product terms(:) with an array of coefficients 
      ! to calculate the value of the polynomial
      SUBROUTINE calcPolynomialTET(x, p_deg, terms, nterms)
      implicit none
      ! the number of terms must be: (p+3)!/(p!*3!)
      ! nterms = (p+1)*(p+2)*(p+3)/6
         real(8), intent(in) :: x(3)
         integer, intent(in) :: p_deg
         real(8), intent(out):: terms(nterms)
         integer, intent(in):: nterms
         !local vars
         integer :: i,j,k,n
         ! fill in the terms
         n=0
         do k=0,p_deg
            do j=0,p_deg-k
               do i=0,p_deg-k-j
                  n=n+1
                  terms(n)=(x(1)**i)*(x(2)**j)*(x(3)**k)
               enddo
            enddo
         enddo

      END SUBROUTINE

      SUBROUTINE createPatchMatrices(A,b,P,nPolyTerms,nQuantDOF,p_deg, &
                                    patchElements,nPatchElements,xPatchGauss, &
                                    distPatchElements, &
                                    gaussValues,NX,NELX,debug2)
      implicit none
      real(8), intent(inout) :: P(nPolyTerms)
      real(8), intent(out) :: A(nPolyTerms,nPolyTerms)
      real(8), intent(out) :: b(nPolyTerms,nQuantDOF)
      integer, intent(in) :: p_deg,nPolyTerms,nQuantDOF,nPatchElements
      integer, intent(in) :: NELX,NX
      integer, intent(in) :: patchElements(nPatchElements)
      real(8), intent(in) :: xPatchGauss(3,nPatchElements)
      real(8), intent(in) :: distPatchElements(nPatchElements)
      real(8), intent(in) :: gaussValues(nQuantDOF,NELX)
      logical, intent(in) :: debug2
      
      ! local
      integer :: iPatchGauss, elemIdx, iEl, i, j, iQuantDOF
      real(8) :: weightGauss
      
      if (nPolyTerms /= (p_deg+3)*(p_deg+2)*(p_deg+1)/6) then
         write(*,*) 'requested degree of patching polynomical:',p_deg
         write(*,*) 'required number of polynomial coefficients: ', &
                     (p_deg+3)*(p_deg+2)*(p_deg+1)/6
         write(*,*) 'nPolyTerms argument passed:',nPolyTerms
         stop
      endif
      P(:) = 0.D0
      A(:,:) = 0.D0
      b(:,:) = 0.D0
      iPatchGauss=0
      do elemIdx = 1,nPatchElements
         iEl = patchElements(elemIdx)
         weightGauss = 1.d0/distPatchElements(elemIdx)
         iPatchGauss=iPatchGauss+1
         CALL calcPolynomialTET(xPatchGauss(:,iPatchGauss), &
                                    p_deg,P(:),nPolyTerms)
         if (debug2) then
            write(997,*) 'Element ', iEl
            CALL printMatrix(xPatchGauss(:,iPatchGauss),1,3, &
                                          'gauss point',997)
         endif
         if (debug2) then
            CALL printMatrix(P(:),1,nPolyTerms,'P vector',997)
         endif
         
         do i=1,nPolyTerms
            do j=1,nPolyTerms
               A(i,j)=A(i,j)+P(i)*P(j)*weightGauss*weightGauss
            enddo
         enddo
         ! set the RHS vector
         do iQuantDOF=1,nQuantDOF
            b(:,iQuantDOF)=b(:,iQuantDOF)+ &
                        P(:)*gaussValues(iQuantDOF,iEl)*weightGauss*weightGauss
         enddo
      enddo
      
      END SUBROUTINE
      

      SUBROUTINE recoveryLSQ_PL(nodalValues,gaussValues,nQuantDOF, &
                             error,debug,staGrainIdx,endGrainIdx)

      implicit none
      
      !arguments
      real(8), intent(out):: nodalValues(nQuantDOF,nSPRPatches)
      real(8), intent(in) :: gaussValues(nQuantDOF,rec_NELX)
      integer, intent(in) :: nQuantDOF
      integer, intent(out):: error
      logical, intent(in) :: debug
      integer, intent(in), optional :: staGrainIdx,endGrainIdx
      ! local variables
      integer :: elemID,elemIdx,staElemIdx,endElemIdx,iGrain
      integer :: iLocNode,jLocNode,iGloNode,jGloNode,iDOF,nEqnsMax,nEqns
      integer :: iPatchNode,jPatchNode,iEqnID,jEqnID,staNodeIdx
      integer :: MDIM
      integer :: firstGrain, lastGrain
      real(8) :: elemJacMat(3,3)
      real(8) :: elemJac, elemVol
      real(8) :: gaussLoading(nQuantDOF)
      real(8) :: TETUnitMatrix(4,4)
      real(8) :: xElemNodes(3,4)
      real(8), allocatable :: FEMUnitMatrix(:,:)
      real(8), allocatable :: nodalValues_Grain(:,:)

      
      MDIM=3
      
      nodalValues(:,:) = 0.D0
      gaussLoading(:) = 0.D0

      CALL getTET4UnitMatrix(TETUnitMatrix)
      ! allocate LSQ matrix and RHS, s.t. largest eqn. system will fit in
      if (present(staGrainIdx) .and. present(endGrainIdx)) then
         nEqnsMax = MAXVAL(nPatchesInGrain(staGrainIdx:endGrainIdx))
         firstGrain = staGrainIdx
         lastGrain = endGrainIdx
      else
         nEqnsMax = MAXVAL(nPatchesInGrain(1:rec_nGrains)) 
         firstGrain = 1
         lastGrain = rec_nGrains         
      endif
      
      allocate(FEMUnitMatrix(nEqnsMax,nEqnsMax))
      allocate(nodalValues_Grain(nEqnsMax,nQuantDOF))

      do iGrain=firstGrain,lastGrain
      
         ! initialize LSQ matrix and RHS for the nodal values within this grain
         nEqns = nPatchesInGrain(iGrain)
         FEMUnitMatrix(:,:)  = 0.D0
         nodalValues_Grain(:,:) = 0.d0
         
         staNodeIdx = listPatchesInGrain(1,iGrain) ! starting node index within this patch
      
         staElemIdx = 1
         if (iGrain /= 1) staElemIdx = rec_grainElementIndx(iGrain-1)
         endElemIdx = rec_grainElementIndx(iGrain)-1
         do elemIdx=staElemIdx,endElemIdx
            elemID=rec_grainElements(elemIdx)
            ! get the coordinates of the element
            do iLocNode=1,rec_NODE
               iGloNode=rec_IJK((elemID-1)*rec_NODE+iLocNode)
               xElemNodes(:,iLocNode) = rec_nodalPositions(:,iGloNode)
            enddo
            !calculate element Jacobian
            CALL calcJacTET4(xElemNodes, elemJacMat, elemJac, elemVol)
            !get element gauss point values
            gaussLoading(:)=gaussValues(:,elemID)
            ! assemble element matrix and forces into the global matrix
            do iLocNode=1,rec_NODE
               iPatchNode=IJK_patchNodes(iLocNode,elemID)
               iEqnID = iPatchNode-staNodeIdx+1

               do jLocNode=1,rec_NODE
                  jPatchNode=IJK_patchNodes(jLocNode,elemID)
                  jEqnID = jPatchNode-staNodeIdx+1
                  FEMUnitMatrix(iEqnID,jEqnID) = &
                     FEMUnitMatrix(iEqnID,jEqnID) &
                   + TETUnitMatrix(iLocNode,jLocNode)*elemJac
               enddo
               
               ! assemble the forces into the solution vector.
               ! DPOSV() will store the solution here
               nodalValues_Grain(iEqnID,:) = &
                     nodalValues_Grain(iEqnID,:) &
                   + gaussLoading(:)*elemJac/24
   !            write(997,*) 'elem ',elemID,' Jac ', elemJac
               if(debug) then
            CALL printMatrix(gaussLoading(:)*elemJac/24,1, &
                        nQuantDOF,'LSQ load vector',997)
               endif
                                 
            enddo
         enddo
         
         ! solve for the nodal values within this grain
         if (debug) then
            CALL printMatrix(FEMUnitMatrix(1:nEqns,1:nEqns),nEqns,nEqns,'FemUnitMatrix',997)
            CALL printMatrix(nodalValues_Grain(1:nEqns,1:nQuantDOF),nEqns,nQuantDOF,'gaussForcing',997)
         end if
         CALL DPOSV('U',nEqns,nQuantDOF,FEMUnitMatrix,nEqnsMax, &
                                    nodalValues_Grain,nEqnsMax,error)
         if (error.NE.0) then
            write(*,*)'DPOSV() call at recoveryLSQ() returned an error.'
            stop
         endif
         
         ! save the nodal values of the grain into the array for the whole domain
         do iDOF = 1,nQuantDOF
            nodalValues(iDOF,staNodeIdx:staNodeIdx+nEqns-1) = nodalValues_Grain(1:nEqns,iDOF)
         enddo
         
      enddo
      
      deallocate(FEMUnitMatrix)
      deallocate(nodalValues_Grain)
      
      END SUBROUTINE
      
      SUBROUTINE recoveryLSQ(nodalValues,gaussValues,nQuantDOF, &
                             G0XYZ,IJK, &
                             grainElementIndx,grainElements,IJK_grainNodes, &
                             nGrainNodes,grainNodesIndices, &
                             error,debug, &
                             staGrainIdx,endGrainIdx) 

      implicit none
      
      !arguments
      real(8), intent(out):: nodalValues(nQuantDOF,rec_nTotGrainNodes)
      real(8), intent(in) :: gaussValues(nQuantDOF,rec_NELX)
      integer, intent(in) :: nQuantDOF
      integer, intent(in) :: IJK(4*rec_NELX)
      real(8), intent(in) :: G0XYZ(3*rec_NX)
      integer, intent(in) :: grainElements(rec_NELX)      
      integer, intent(in) :: grainElementIndx(rec_nGrains)
      integer, intent(in) :: IJK_grainNodes(4,rec_NELX)
      integer, intent(in) :: nGrainNodes(rec_nGrains)        
      integer, intent(in) :: grainNodesIndices(rec_nTotGrainNodes)
      integer, intent(out):: error
      logical, intent(in) :: debug
      integer, intent(in), optional :: staGrainIdx,endGrainIdx

      ! local variables
      integer :: elemID,elemIdx,staElemIdx,endElemIdx,iGrain
      integer :: iLocNode,jLocNode,iGloNode,jGloNode,iDOF,nEqnsMax,nEqns
      integer :: iGrainNodeID,jGrainNodeID,iEqnID,jEqnID,staGrainNodeID
      integer :: MDIM
      integer :: firstGrain, lastGrain
      real(8) :: elemJacMat(3,3)
      real(8) :: elemJac, elemVol
      real(8) :: gaussLoading(nQuantDOF)
      real(8) :: TETUnitMatrix(4,4)
      real(8) :: xElemNodes(3,4)
      real(8), allocatable :: FEMUnitMatrix(:,:)
      real(8), allocatable :: nodalValues_Grain(:,:)

      
      MDIM=3
      
      error = 1
      if (.not.grainNodesInitialized) return
      
      nodalValues(:,:) = 0.D0
      gaussLoading(:) = 0.D0
      
      if (staGrainIdx==0 .and. endGrainIdx==0) then
         error=0
         return
      endif

      CALL getTET4UnitMatrix(TETUnitMatrix)
      ! allocate LSQ matrix and RHS, s.t. largest eqn. system will fit in
      if (present(staGrainIdx) .and. present(endGrainIdx)) then
         nEqnsMax = MAXVAL(nGrainNodes(staGrainIdx:endGrainIdx))
         firstGrain = staGrainIdx
         lastGrain = endGrainIdx
      else
         nEqnsMax = MAXVAL(nGrainNodes(1:rec_nGrains))
         firstGrain = 1
         lastGrain = rec_nGrains         
      endif
      
      allocate(FEMUnitMatrix(nEqnsMax,nEqnsMax))
      allocate(nodalValues_Grain(nEqnsMax,nQuantDOF))

      do iGrain=firstGrain,lastGrain
      
         ! initialize LSQ matrix and RHS for the nodal values within this grain
         nEqns = nGrainNodes(iGrain)
         FEMUnitMatrix(:,:)  = 0.D0
         nodalValues_Grain(:,:) = 0.d0
         
         staGrainNodeID = 1
         if (iGrain /= 1) staGrainNodeID = grainNodesIndices(iGrain-1)
      
         staElemIdx = 1
         if (iGrain /= 1) staElemIdx = grainElementIndx(iGrain-1)
         endElemIdx = grainElementIndx(iGrain)-1
         
         do elemIdx=staElemIdx,endElemIdx
            elemID=grainElements(elemIdx)
            ! get the coordinates of the element
            CALL getElemXNodes(elemID,IJK,G0XYZ,rec_NODE,xElemNodes)
            !calculate element Jacobian
            CALL calcJacTET4(xElemNodes, elemJacMat, elemJac, elemVol)
            !get element gauss point values
            gaussLoading(:)=gaussValues(:,elemID)
            ! assemble element matrix and forces into the global matrix
            do iLocNode=1,rec_NODE
               iGrainNodeID=IJK_grainNodes(iLocNode,elemID)
               iEqnID = iGrainNodeID-staGrainNodeID+1

               do jLocNode=1,rec_NODE
                  jGrainNodeID=IJK_grainNodes(jLocNode,elemID)
                  jEqnID = jGrainNodeID-staGrainNodeID+1
                  FEMUnitMatrix(iEqnID,jEqnID) = &
                     FEMUnitMatrix(iEqnID,jEqnID) &
                   + TETUnitMatrix(iLocNode,jLocNode)*elemJac
               enddo
               
               ! assemble the forces into the solution vector.
               ! DPOSV() will store the solution here
               nodalValues_Grain(iEqnID,:) = &
                     nodalValues_Grain(iEqnID,:) &
                   + gaussLoading(:)*elemJac/24
   !            write(997,*) 'elem ',elemID,' Jac ', elemJac
               if(debug) then
            CALL printMatrix(gaussLoading(:)*elemJac/24,1, &
                        nQuantDOF,'LSQ load vector',997)
               endif
                                 
            enddo
         enddo
         
         ! solve for the nodal values within this grain
         if (debug) then
            CALL printMatrix(FEMUnitMatrix(1:nEqns,1:nEqns),nEqns,nEqns,'FemUnitMatrix',997)
            CALL printMatrix(nodalValues_Grain(1:nEqns,1:nQuantDOF),nEqns,nQuantDOF,'gaussForcing',997)
         end if
         CALL DPOSV('U',nEqns,nQuantDOF,FEMUnitMatrix,nEqnsMax, &
                                    nodalValues_Grain,nEqnsMax,error)
         if (error.NE.0) then
            write(*,*)'DPOSV() call at recoveryLSQ() returned an error.'
            stop
         endif
         
         ! save the nodal values of the grain into the array for the whole domain
         do iDOF = 1,nQuantDOF
            nodalValues(iDOF,staGrainNodeID:staGrainNodeID+nEqns-1) = nodalValues_Grain(1:nEqns,iDOF)
         enddo
         
      enddo
      
      deallocate(FEMUnitMatrix)
      deallocate(nodalValues_Grain)
      
      END SUBROUTINE
      
      SUBROUTINE rec_READSTR(fileNum,lineStr,error)
      IMPLICIT REAL*8(A-H,O-Z)
      ! this code skips 1 line of text in the input file.
      integer, intent(in) :: fileNum
      character(150), intent(out) :: lineStr
      integer, intent(out) :: error
      read(fileNum,'(A)',iostat=error) lineStr
      RETURN
      END SUBROUTINE
      
      SUBROUTINE calcJacTET4(xElemNodes, elemJacMat, elemJac, elemVol)
      implicit none
      real(8), intent(in) :: xElemNodes(3,4)
      real(8), intent(out):: elemJacMat(3,3), elemJac, elemVol
      real(8):: XX(3),YY(3),ZZ(3)
      integer :: iCoord, iDir

      do iCoord=1,3
         do iDir=1,3
            elemJacMat(iCoord,iDir) =     &
               xElemNodes(iCoord,iDir)-xElemNodes(iCoord,4)
         enddo
      enddo
      
      elemJac= &
          elemJacMat(1,1)*elemJacMat(2,2)*elemJacMat(3,3)   &
         -elemJacMat(1,1)*elemJacMat(2,3)*elemJacMat(3,2)   &
         -elemJacMat(2,1)*elemJacMat(1,2)*elemJacMat(3,3)   &
         +elemJacMat(2,1)*elemJacMat(1,3)*elemJacMat(3,2)   &
         +elemJacMat(3,1)*elemJacMat(1,2)*elemJacMat(2,3)   &
         -elemJacMat(3,1)*elemJacMat(1,3)*elemJacMat(2,2)
     
      elemVol = elemJac/6
      
      END SUBROUTINE

      SUBROUTINE getElemXNodes(elemID,IJK,GXYZ,NODE,xNodes)
      implicit none
      integer, intent(in) :: elemID
      integer, intent(in) :: IJK(:)
      real(8), intent(in) :: GXYZ(:)
      integer, intent(in) :: NODE
      real(8), intent(out):: xNodes(3,NODE)
      integer :: iNode,iGloNode    
            
      do iNode=1,NODE
         iGloNode=IJK((elemID-1)*NODE+iNode)
         xNodes(:,iNode)=GXYZ((iGloNode-1)*3+1:iGloNode*3)
      enddo
      
      END SUBROUTINE

      SUBROUTINE getElemXCenter(elemID,IJK,GXYZ,NODE,xElemCenter)
      implicit none
      integer, intent(in) :: elemID
      integer, intent(in) :: IJK(:)
      real(8), intent(in) :: GXYZ(:)
      integer, intent(in) :: NODE
      real(8), intent(out):: xElemCenter(3)
      
      real(8) :: xElemNodes(3,NODE)
      integer :: i
      
      xElemCenter(:)=0.D0
      CALL getElemXNodes(elemID,IJK,GXYZ,NODE,xElemNodes)
      do i=1,NODE
         xElemCenter(:) = xElemCenter(:) + xElemNodes(:,i)
      enddo
      xElemCenter(:) = xElemCenter(:) / NODE
      END SUBROUTINE      
      end module
      
